package ReversiGame;

/**
 * Класс для помощи в просчете возможных ходов
 */
public final class MoveCalculator {
    private MoveCalculator() {
    }

    /**
     * Рассчитывает все ячейки, куда в данный момент может быть поставлена фишка игрока и
     * считает для каждой такой клетки количество возможных очков, которые будут получены если поставить в нее фишку.
     * @param colorOfMove задает цвет фишек, для которых делать рассчеты.
     * @return двумерный массив координат возможных ходов
     */
    public static int[][] getAllPossibleCellsToMove(boolean colorOfMove) {
        return new int[1][1];
    }

    /**
     * Находит вариант лучшего хода в текущий момент, играя на высокой сложности.
     * <p>
     * На этой сложности анализируется количество LEVEL_OF_COMPLEXITY будущих возможных хода противника,
     * и выдается вариант хода с наибольшим выигрышем по очкам.
     * <p>
     * @param levelOfComplexity задает количество шагов, которое нужно просматривать наперед с оценкой
     *                          возможных ответных ходов противника.
     *                          0 означает отсутствие оценки возможных ответов противника.
     * @param playingField задает игровое поле, для которого рассчитывать ходы.
     * @param colorOfMove задает цвет фишек, для которых делать рассчеты.
     * @return Массив из трех значений: позиция по x, позиция по y, куда нужно поставить фишку,
     *         а также количество очков, на которое увеличется отрыв от противника.
     */
    public static int[] getBestMoveWithComplexity(int levelOfComplexity, int[][] playingField, boolean colorOfMove) {
        return new int[2];
    }
}
